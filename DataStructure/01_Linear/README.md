### 목차

1. [단순 구조](#1-단순-구조)
   1. 레코드, Record
2. [선형 구조](#2-선형-구조)
   1. 순차 리스트, Array List
   2. 연결 리스트, Linked List
   3. 스택, Stack
   4. 큐, Queue
   5. 덱, Deque

<br>

<a href="https://github.com/jarvis08/Reminders">메인으로</a>

<br>

# 1. 단순 구조

기본 자료 구조인 단순 구조에는 네 가지가 있다.

1. 정수
2. 실수
3. 문자
4. 문자열

<br>

## 1-1. 레코드, Record

논리적으로 서로 연관이 있는 자료 원소들의 집합체이다.

i.g., 학번, 성명, 성별, 주민번호, 주소, 전화번호 등

- 한 레코드 내에 있는 필드들의 이름은 모두 달라야 하지만, 각 필드들의 자료형은 같지 않아도 된다.
- 각 원소(필드)마다 고유한 이름으로 구별하므로 원소의 순서를 임의로 변경할 수 있다.

<br>

<a href="#목차" style="text-align: right;">맨 위로</a>

<br>

# 2. 선형 구조

> element와 element의 관계가 1:1자기 자신에서 이어질 수 있는 경우의 수 = 1개2차원일 경우, 같은 차원 당 경우의 수 = 1개물리적 구조 == 논리적 구조

선형 구조는 자료 간의 관계가 `1:1`인 자료 구조를 말한다.

선형 구조의 종류는 다음과 같다.

1. 순차 리스트, List
2. 연결 리스트, Linked List
3. 스택, Stack
4. 큐, Queue
5. 덱, Deque

<br>

<br>

## **2-1. 순차 리스트, Array List**

C/C++ 에서의 배열(Array)과 파이썬에서의 리스트(List)를 지칭하는 리스트이다.

<br>

<br>

## **2-2. 연결 리스트, Linked List**

### 단순 연결 리스트, Singly Linked List

- 구조 

  - 노드가 하나의 Link Field에 의해 다음 노드와 연결되는 구조

    C의 경우 `자기 참조 구조체` 사용이 필요

  - 헤드가 처음 노드를 가리키고, Link Field가 연속적으로 다음 노드를 가리킴

  - 최종적으로 NULL을 가리키는 노드가 가장 마지막 노드

<br>

### 이중 연결 리스트, Doubly Linked List

앞 순서의 노드를 찾으려면, 단순 연결 리스트는 처음부터 다시 순회해야 하며, 원형 연결 리스트는 한바퀴를 순회해야 하는 단점이 있으므로, 이를 개선하고자 등장했다.

- Head는 첫 번째 원소의 주소(Link Field만이 존재)만을 보유
- 첫 번째 원소의 `prev`는 `null`

<br>

### 원형 연결 리스트, Circular Linked List

단순 연결 리스트의 마지막 노드의 링크 필드가 첫 노드를 가리키도록 하는 구조이다.

<br>

<br>

## **2-3. 스택, Stack**

1차원 배열을 사용하여 구현할 경우 구현이 용이하지만, 스택의 크기를 변경하기가 어렵다는 것이 단점이 있다.

따라서 연결 리스트를 사용하여 메모리를 관리하는 것이 효율적이다.

- 식당에서 스프링으로 접시를 받쳐 올려주는 접시 스택에서 유래됐다.

- 스택의 연산

  - INSERT - PUSH
  - DELETE - POP

- 후입 선출(LIFO, Last-in Frist-out)

  마지막으로 삽입한 자료를 가장 먼저 꺼낸다.

- 저장소 자체를 스택이라 부르기도 한다.

- Function Call에서의 응용

  프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리

  (함수 호출 순서의 역순으로 `return`을 수행)

  - 컴퓨터의 메모리 

    - Code

    - Data

      전역 변수

    - Heap & Stack

      local 변수, 함수 호출 시 함수의 내용

<br>

<br>

## **2-4. 큐, Queue**

- 큐의 종류

  - 선형 큐

  초기값: `front = rear = -1`

  - 원형 큐

    초기값: `front = rear = 0`

  - 우선순위 큐

- 큐의 FIFO 특성은 계산대에 줄을 서 있는 사람을 서비스하는 일과 유사하다.

- 큐의 연산

  - INSERT - ENQUEUE
  - DELETE - DEQUEUE

- 머리(`head`)와 꼬리(`tail`) 인자

  - 새로 도착한 손님이 줄의 맨 끝에 위치하는 것 처럼 새 원소는 꼬리(`tail`)에 위치
  - 큐의 삭제는 가장 오래 기다린, 대기열 맨 앞의 머리(`head`)
  - 머리를 `front`, 꼬리를 `rear`로 지칭하기도 한다.
  - `front`/`head`를 `첫 원소 index-1`, 그리고 `tail`/`rear`를 `마지막 원소의 index`로 처리하기도 한다.

- 작업 버퍼 큐, 프로세스 스케줄링, 대기 행렬을 모델링하는 시뮬레이션(큐잉이론) 등에서 사용

<br>

<br>

## **2-5. 덱, Deque**

스택과 큐의 동작을 복합시킨 방식이며, 두 가지가 있다.

- 스크롤: 양쪽으로 삭제가 가능하며, 한 쪽으로만 삽입할 수 있다.
- 셀프: 양쪽으로 삽입할 수 있으며, 한 쪽으로만 삭제할 수 있다.

<br>

<a href="#목차" style="text-align: right;">맨 위로</a>